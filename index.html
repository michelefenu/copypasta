<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CopyPasta - 100% Private Pastebin</title>
    <style>
      :root {
        --bg: #f5f5f5;
        --fg: #212529;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --bg: #11262b;
          --fg: #bedfe5;
        }
      }
      body.dark {
        --bg: #11262b;
        --fg: #bedfe5;
      }
      body.light {
        --bg: #f5f5f5;
        --fg: #212529;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: ui-monospace, monospace;
        font-size: 14px;
        background: var(--bg);
        color: var(--fg);
        margin: 0;
        padding: 24px 24px 0 24px;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      h1 {
        font-size: 24px;
        margin: 0;
      }

      p {
        margin: 0 0 10px 0;
      }

      p.description {
        padding: 10px 0;
        font-size: 16px;
      }

      hr {
        margin: 10px 0;
        border: none;
        border-top: 1px solid var(--fg);
      }

      #inputMode,
      #view-mode {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
      }

      textarea,
      input[type="text"] {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--fg);
        background: var(--bg);
        color: var(--fg);
        font: inherit;
      }

      textarea {
        flex: 1;
        resize: none;
        min-height: 200px;
      }

      a.button {
        font-size: 18px;
        cursor: pointer;
        text-decoration: none;
        display: inline-block;
        background: var(--bg);
        color: var(--fg);
      }

      .dark a.button:hover {
        color: #e9854c;
      }

      .light a.button:hover {
        color: #007bff;
      }

      a.button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        flex-shrink: 0;
      }

      .footer {
        flex-shrink: 0;
      }

      .bottom-bar {
        display: flex;
        flex-direction: column;
        align-items: start;
        justify-content: center;
        margin-top: 10px;
        min-height: 50px;
      }

      .bottom-actions {
        display: flex;
        gap: 10px;
        width: 100%;
      }

      #inputActions.hide {
        display: none;
      }

      #output {
        display: none;
        gap: 10px;
        align-items: center;
        width: 100%;
      }

      #output.show {
        display: flex;
      }

      #output input {
        flex: 1;
        margin: 0;
      }

      .actions-right {
        display: flex;
        gap: 10px;
        flex-shrink: 0;
      }

      .info {
        padding: 3px;
        color: #000000;
        background-color: #9f9f9f;
        margin: 5px 0;
        font-size: 12px;
      }

      .error {
        padding: 3px;
        color: #000000;
        background-color: #ff6b6b;
        margin: 5px 0;
        font-size: 12px;
      }

      .success {
        padding: 3px;
        color: #000000;
        background-color: #6bff88;
        margin: 5px 0;
        font-size: 12px;
      }

      body.light #lightsOn,
      body.dark #lightsOff {
        display: none;
      }

      @media (prefers-color-scheme: dark) {
        body:not(.light):not(.dark) #lightsOff {
          display: none;
        }
      }
      @media (prefers-color-scheme: light) {
        body:not(.light):not(.dark) #lightsOn {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>CopyPasta - 100% Private Pastebin (๑ᵔ⤙ᵔ๑)</h1>
      <a href="#" class="button" id="lightsOff">[ Lights Off ]</a>
      <a href="#" class="button" id="lightsOn">[ Lights On ]</a>
    </div>

    <div id="inputMode">
      <p class="description">
        Paste your text below, compress it into a shareable URL, and send it to
        anyone.
      </p>
      <textarea id="inputText" autofocus></textarea>
      <div style="height: 14px">
        <div id="infoMsg" class="info" style="display: block"></div>
        <div id="errorMsg" class="error" style="display: none"></div>
        <div id="successMsg" class="success" style="display: none"></div>
      </div>
      <div class="bottom-bar">
        <div class="bottom-actions" id="inputActions">
          <a href="#" class="button" id="compressBtn">[ Generate Link ]</a>
          <a href="#" class="button" id="clearBtn">[ Clear ]</a>
        </div>
        <div id="output">
          <input type="text" id="outputUrl" readonly />
          <div class="actions-right">
            <a href="#" class="button" id="copyBtn">[ Copy ]</a>
            <a href="#" class="button" id="newBtn">[ Cancel ]</a>
          </div>
        </div>
      </div>
    </div>

    <div id="view-mode" style="display: none">
      <p class="description">Someone else's text:</p>
      <textarea id="viewText" readonly></textarea>
      <div class="bottom-bar">
        <div class="bottom-actions">
          <a href="#" class="button" id="editTextBtn">[ Edit ]</a>
          <a href="#" class="button" id="createNewBtn">[ Create Your Own ]</a>
        </div>
      </div>
    </div>

    <div class="footer">
      <hr />
      <p>
        <small
          >All compression happens in your browser. No data is sent to any
          server.
        </small>
      </p>
    </div>

    <script>
      const getElement = (id) => document.getElementById(id);

      const body = document.body;
      const inputText = getElement("inputText");
      const compressBtn = getElement("compressBtn");
      const clearBtn = getElement("clearBtn");
      const inputActions = getElement("inputActions");
      const outputDiv = getElement("output");
      const outputUrl = getElement("outputUrl");
      const copyBtn = getElement("copyBtn");
      const newBtn = getElement("newBtn");
      const errorMsg = getElement("errorMsg");
      const infoMsg = getElement("infoMsg");
      const successMsg = getElement("successMsg");
      const inputMode = getElement("inputMode");
      const viewMode = getElement("view-mode");
      const viewText = getElement("viewText");

      // Theme
      const savedTheme = localStorage.getItem("theme");
      if (savedTheme) body.className = savedTheme;
      else
        body.className = matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light";

      getElement("lightsOff").onclick = getElement("lightsOn").onclick = (
        e
      ) => {
        e.preventDefault();
        const newTheme = body.className === "dark" ? "light" : "dark";
        body.className = newTheme;
        localStorage.setItem("theme", newTheme);
      };

      // Messages
      const showError = (msg) => {
        errorMsg.textContent = msg;
        errorMsg.style.display = "block";
        successMsg.style.display = "none";
        infoMsg.style.display = "none";
      };
      const showSuccess = (msg) => {
        successMsg.textContent = msg;
        successMsg.style.display = "block";
        errorMsg.style.display = "none";
        infoMsg.style.display = "none";
      };
      const hideMessages = () => {
        errorMsg.style.display = successMsg.style.display = "none";
        infoMsg.style.display = "block";
      };

      // Compression
      async function processStream(data, isCompress) {
        const stream = new ReadableStream({
          start(c) {
            c.enqueue(data);
            c.close();
          },
        });
        const processed = stream.pipeThrough(
          isCompress
            ? new CompressionStream("gzip")
            : new DecompressionStream("gzip")
        );
        const chunks = [];
        const reader = processed.getReader();
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          chunks.push(value);
        }
        const result = new Uint8Array(
          chunks.reduce((acc, c) => acc + c.length, 0)
        );
        let offset = 0;
        for (const chunk of chunks) {
          result.set(chunk, offset);
          offset += chunk.length;
        }
        return result;
      }

      const compressText = (text) =>
        processStream(new TextEncoder().encode(text), true);
      const decompressText = async (data) =>
        new TextDecoder().decode(await processStream(data, false));

      const arrayBufferToBase64 = (buf) =>
        btoa(String.fromCharCode(...new Uint8Array(buf)))
          .replace(/\+/g, "-")
          .replace(/\//g, "_")
          .replace(/=+$/, "");
      const base64ToArrayBuffer = (b64) => {
        const std = b64.replace(/-/g, "+").replace(/_/g, "/");
        const bin = atob(std + "=".repeat((4 - (std.length % 4)) % 4));
        return new Uint8Array([...bin].map((c) => c.charCodeAt(0)));
      };

      // Browser check
      if (!window.CompressionStream) {
        showError(
          "Your browser does not support the Compression Streams API. Please use a modern browser."
        );
        compressBtn.disabled = true;
      }

      // Events
      compressBtn.onclick = async (e) => {
        e.preventDefault();
        const text = inputText.value.trim();
        if (!text) return showError("Please enter some text to compress.");

        hideMessages();
        compressBtn.disabled = true;
        compressBtn.textContent = "Compressing...";

        try {
          const compressed = await compressText(text);
          const base64 = arrayBufferToBase64(compressed);
          outputUrl.value = `${location.origin}${location.pathname}#${base64}`;
          inputActions.classList.add("hide");
          outputDiv.classList.add("show");
          showSuccess("Link generated successfully!");
        } catch (err) {
          showError("Error compressing text: " + err.message);
        } finally {
          compressBtn.disabled = false;
          compressBtn.textContent = "[ Generate Link ]";
        }
      };

      clearBtn.onclick = (e) => {
        e.preventDefault();
        inputText.value = "";
        inputActions.classList.remove("hide");
        outputDiv.classList.remove("show");
        hideMessages();
        updateInfoBar();
      };

      copyBtn.onclick = async (e) => {
        e.preventDefault();
        try {
          await navigator.clipboard.writeText(outputUrl.value);
          showSuccess("Link copied to clipboard!");
        } catch {
          outputUrl.select();
          document.execCommand("copy");
          showSuccess("Link copied to clipboard!");
        }
      };

      newBtn.onclick = (e) => {
        e.preventDefault();
        inputActions.classList.remove("hide");
        outputDiv.classList.remove("show");
        hideMessages();
      };

      getElement("editTextBtn").onclick = (e) => {
        e.preventDefault();
        inputText.value = viewText.value;
        location.hash = "";
        viewMode.style.display = "none";
        inputMode.style.display = "flex";
        hideMessages();
      };

      getElement("createNewBtn").onclick = (e) => {
        e.preventDefault();
        location.hash = "";
        viewMode.style.display = "none";
        inputMode.style.display = "flex";
        hideMessages();
      };

      // Load from URL
      async function checkUrlHash() {
        const hash = location.hash.substring(1);
        if (!hash) return;

        try {
          const compressed = base64ToArrayBuffer(hash);
          const text = await decompressText(compressed);
          viewText.value = text;
          inputMode.style.display = "none";
          viewMode.style.display = "flex";
        } catch (err) {
          showError(
            "Error decompressing text from URL. The link may be invalid or corrupted."
          );
          console.error("Decompression error:", err);
        }
      }

      checkUrlHash();
      addEventListener("hashchange", checkUrlHash);

      // Update info bar with character count and estimated URL length
      let debounceTimer;
      async function updateInfoBar() {
        const text = inputText.value;
        const charCount = text.length;

        if (charCount === 0) {
          infoMsg.textContent = "Ready to paste";
          return;
        }

        // Show character count immediately
        infoMsg.textContent = `Characters: ${charCount} | Estimating URL length...`;

        // Debounce the compression calculation
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(async () => {
          try {
            const compressed = await compressText(text);
            const base64 = arrayBufferToBase64(compressed);
            const baseUrl = `${location.origin}${location.pathname}`;
            const estimatedUrlLength = baseUrl.length + 1 + base64.length; // +1 for #

            // Calculate compression rate
            const originalBytes = new TextEncoder().encode(text).length;
            const compressedBytes = compressed.length;
            const compressionRate = (
              ((originalBytes - compressedBytes) / originalBytes) *
              100
            ).toFixed(1);

            infoMsg.textContent = `Characters: ${charCount} | Estimated URL length: ${estimatedUrlLength}`;
            if (compressionRate > 0) {
              infoMsg.textContent += ` | Compression rate: ${compressionRate}%`;
            } else {
              infoMsg.textContent += ` | Compression rate: 0%`;
            }
          } catch (err) {
            infoMsg.textContent = `Characters: ${charCount} | URL length: (error calculating)`;
          }
        }, 500); // Wait 500ms after user stops typing
      }

      inputText.addEventListener("input", () => {
        updateInfoBar();

        // If output URL is showing and user modifies textarea, go back to edit mode
        if (outputDiv.classList.contains("show")) {
          inputActions.classList.remove("hide");
          outputDiv.classList.remove("show");
          hideMessages();
        }
      });
      updateInfoBar(); // Initial update
    </script>
  </body>
</html>
